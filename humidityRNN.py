"""CSC413 Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xr8etVkmg_7FKOy-5_RSMseG_G0q_Vgp
"""

import pandas as pd
import torch
import tensorflow as tf
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from keras.models import Sequential
from sklearn.metrics import mean_squared_error, mean_absolute_error
from keras.layers import Dense, SimpleRNN
from keras.optimizers import RMSprop
from keras.callbacks import Callback

file_paths = ["city_attributes.csv", "humidity.csv", "pressure.csv", "temperature.csv",
              "weather_description.csv", "wind_direction.csv", "wind_speed.csv"]
humidity = pd.read_csv("humidity.csv")
pressure = pd.read_csv("pressure.csv")
temperature = pd.read_csv("temperature.csv")

humidity_TO = humidity[['datetime','Toronto']]
pressure_TO = pressure[['datetime','Toronto']]
temperature_TO = temperature[['datetime','Toronto']]
humidity_TO.head(10)

print(humidity_TO.shape)
print(temperature_TO.shape)
print(pressure_TO.shape)

print(humidity_TO.isna().sum()['Toronto'])
print(temperature_TO.isna().sum()['Toronto'])
print(pressure_TO.isna().sum()['Toronto'])

#We observed some NA values, so we will fill it up with linear interpolation assuming that the time series weather data is reliable
#and doesn't have extreme volatility.
humidity_TO.interpolate(inplace = True)
humidity_TO.dropna(inplace = True)
temperature_TO.interpolate(inplace = True)
temperature_TO.dropna(inplace = True)
pressure_TO.interpolate(inplace = True)
pressure_TO.dropna(inplace = True)

#We are using around 80% of the data for the training and 20% for the test
train = np.array(humidity_TO['Toronto'][:35000])
test = np.array(humidity_TO['Toronto'][35000:])
train=train.reshape(-1,1)
test=test.reshape(-1,1)
print(train.shape)
print(test.shape)

step = 12 #Assuming that 12 hours of humidity data will be enough to correctly predict 13. hour.
test = np.append(test,np.repeat(test[-1,],step))
train = np.append(train,np.repeat(train[-1,],step))

def matrix_conversion(data, step):
    a, b = [], []
    for i in range(len(data)-step):
        d = i + step
        a.append(data[i:d,])
        b.append(data[d,])
    return np.array(a), np.array(b)

train_x,train_y =matrix_conversion(train,step)
test_x,test_y =matrix_conversion(test,step)
train_x = np.reshape(train_x, (train_x.shape[0], 1, train_x.shape[1]))
test_x = np.reshape(test_x, (test_x.shape[0], 1, test_x.shape[1]))

def create_RNN(units = 128, embed_size = 12, dense = 32, learning_rate = 0.005):
    model = Sequential()
    model.add(SimpleRNN(units = units, input_shape = (1,embed_size), activation = "relu"))
    model.add(Dense(dense, activation = "relu"))
    model.add(Dense(1))
    model.compile(loss = 'mean_squared_error', optimizer=RMSprop(lr = learning_rate), metrics=['mse'])
    return model

humidity_model = create_RNN(units = 128, embed_size = 12, dense = 32, learning_rate = 0.005)
humidity_model.summary()
batch = 12
num_epochs = 1000

class HumidityCallback(Callback):
    def on_epoch_end(self, epoch, logs = None):
        if (epoch + 1) % 50 == 0 and epoch > 0:
            print("Epoch number {} done".format(epoch + 1))

humidity_model.fit(train_x, train_y,
          epochs = num_epochs,
          batch_size = batch,
          callbacks=[HumidityCallback()], verbose =0 )

plt.figure(figsize=(14,10))
plt.title("Epochs vs RMSE",fontsize = 14)
plt.plot(np.sqrt(humidity_model.history.history['loss']), c = 'k', lw = 2)
plt.grid(True)
plt.xlabel("Epochs", fontsize = 12)
plt.ylabel("Root Mean Squared Error", fontsize = 12)
plt.xticks(fontsize = 12)
plt.yticks(fontsize = 12)
plt.show()

train_predict = humidity_model.predict(train_x)
test_predict = humidity_model.predict(test_x)
predicted = np.concatenate((train_predict,test_predict), axis = 0)

index = humidity_TO.index.values

if predicted.shape[0] > index.shape[0]:
    predicted = predicted[:index.shape[0]]

predicted = predicted.ravel()  # This flattens the array to ensure it matches 'index'
plt.figure(figsize=(30,10))
plt.title("Humidity Model: Target vs. Predicted", fontsize=15)
plt.plot(index, humidity_TO['Toronto'].values[:index.shape[0]], color='blue')  # Ensure this is also correctly sized
plt.plot(index, predicted, color='orange', alpha=0.75)
plt.legend(['Predicted Data', 'Target Data'], fontsize=13)
plt.axvline(x=index[35000], color="red")  # Check if 35000 is the correct index for your test/train split visualization
plt.grid(True)
plt.ylim(-10, 110)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()

